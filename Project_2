# Introduction
# This project is worked by Chenjia Li and Shuorong Zhu
# TA:Liam Schramm


# import part
import random
from collections import deque


# function
def randomS(l):
    lnt = len(l)
    rn = random.randint(1, lnt)
    return l[rn - 1]


def sortL(l):
    if l == []:
        return l
    count = 0
    for i in l:
        l[count] = int(i)
        count = count + 1
    l.sort()
    count = 0
    for i in l:
        l[count] = str(i)
        count = count + 1
    return l

# bfs
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.parent = None


class lList:
    def __init__(self):
        self.head = None

# class part
class graph:

    def __init__(self):
        self.graph = {}

    def addNode(self, k):
        # neighbours,target,agent
        self.graph[str(k)] = [[], 0, 0]  # 0 means not at the this Node

    def addEdge(self, k, val):
        if len(self.graph[str(k)][0]) == 3:
            # False, not able to add any more edges because it has reached maximal degree
            return 0
        else:
            list_temp = self.graph[str(k)][0]
            list_temp.append(str(val))
            self.graph[str(k)][0] = list_temp
            return 1

    def printNb(self):
        for p1, p2 in self.graph.items():
            if len(p2[0]) == 0:
                print("Node " + p1 + " has no edge.")
            if len(p2[0]) == 1:
                print("The Node " + p1 + " is connected to Node " + p2[0][0] + ".")
            if len(p2[0]) == 2:
                print("The Node " + p1 + " is connected to Nodes " + p2[0][0] + " and " + p2[0][1] + ".")
            if len(p2[0]) == 3:
                print("The Node " + p1 + " is connected to Nodes " + p2[0][0] + ", " + p2[0][1] + ", and " + p2[0][
                    2] + ".")

    def EvnSet(self, numN):
        for i in range(1, numN + 1):
            g.addNode(i)
            if i == numN:
                self.addEdge(i, i - 1)
                self.addEdge(i, 1)
            elif i == 1:
                self.addEdge(i, i + 1)
                self.addEdge(i, numN)
            else:
                self.addEdge(i, i - 1)
                self.addEdge(i, i + 1)
        newEcount = 0
        while not newEcount == 10:
            n1 = randomS(list(self.graph))
            if len(self.graph[n1][0]) == 3:
                continue
            n2 = n1
            while n2 == n1 or n2 in self.graph[n1][0] or len(self.graph[n2][0]) == 3:
                n2 = randomS(list(self.graph))
            self.addEdge(n1, n2)
            self.addEdge(n2, n1)
            newEcount = newEcount + 1
        for i in range(1, numN + 1):
            self.graph[str(i)][0] = sortL(self.graph[str(i)][0])

    def setA(self, pos):
        self.graph[str(pos)][2] = 1

    def setT(self, pos):
        self.graph[str(pos)][1] = 1

    def printT(self):
        for i in list(self.graph):
            if self.graph[i][1] == 1:
                print("Target is currently located at Node " + i + ".")
                return i

    def printA(self):
        for i in list(self.graph):
            if self.graph[i][2] == 1:
                print("Agent is currently located at Node " + i + ".")
                return i

    def clearAT(self):
        # function for set all the agent and target as 0
        t = self.printT()
        a = self.printA()
        self.graph[t][1] = 0
        self.graph[a][2] = 0
        print("All the data are reset")
        pass

#-------------------------------------------------------------
#Code for agent0
    def agent0(self):
        start_pos_a = randomS(list(self.graph))
        self.graph[start_pos_a][2] = 1

    def target_randomwalk(self, cur_pos):
        self.graph[cur_pos][1] = 0
        nb_list = self.graph[cur_pos][0]
        next_pos = randomS(nb_list)
        self.graph[next_pos][1] = 1
        
    def agent0_main(self, t_pos):
        self.setT(str(t_pos))
        self.agent0()
        a = self.printA()
        t = self.printT()
        while not t == a:
            self.target_randomwalk(t)
            print("After one timestep move")
            t = self.printT()
        if t == a:
            print("Target is catched by agent_0 at position " + t + "!")
            
        
#-------------------------------------------------------------
#Code for agent1

    
    def bfs(self):
        a_pos = self.printA()
        t_pos = self.printT()
        q = [a_pos]
        visited = []
        ll = lList()
        ll.head = Node(a_pos)
        cur_node = ll.head
        
        
        while not q == []:
            q = deque(q)
            cur = q.popleft()
            q = list(q)
            visited.append(cur)
            check_node = ll.head
            if check_node.data == cur:
                prev_node = check_node
            else:
                while not check_node.data == cur:
                    check_node = check_node.next
                    prev_node = check_node
                    #then we get the parent node which should be assigned to connected node
            
            if cur == t_pos:
                while not prev_node.parent == ll.head:
                    prev_node = prev_node.parent
                return prev_node.data
            
            for item in self.graph[cur][0]:
                if item not in visited:
                    q.append(item)
                    cur_node.next = Node(item)
                    cur_node = cur_node.next
                    cur_node.parent = prev_node
        print("Path not found")
        return False

    def agent1_main(self, t_pos):
        self.setT(t_pos)
        self.agent0()
        a = self.printA()
        t = self.printT()
        if t == a:
            print("Target is catched by agent_0 at position " + t + "!")
            return True
        else:
            while not t == a:
                print("After one timestep, Tagret move to:")
                self.target_randomwalk(t)
                t = self.printT()
                if t == a:
                    print("Target is catched by agent_0 at position " + t + "!")
                    return True
                a_next_pos = self.bfs()
                self.graph[a][2] = 0
                self.graph[a_next_pos][2] = 1
                a = a_next_pos
                if t == a:
                    print("Target is catched by agent_1 at position " + t + "!")
                    return True
        return False
#-------------------------------------------------------------
#Code for agent2
        
    def DFS(self):
        a_pos = self.printA()
        t_pos = self.printT()
        q = [a_pos]
        visited = []
        ll = lList()
        ll.head = Node(a_pos)
        cur_node = ll.head
        
        
        while not q == []:
            cur = q.pop()
            visited.append(cur)
            check_node = ll.head
            if check_node.data == cur:
                prev_node = check_node
            else:
                while not check_node.data == cur:
                    check_node = check_node.next
                    prev_node = check_node
                    #then we get the parent node which should be assigned to connected node
            
            if cur == t_pos:
                while not prev_node.parent == ll.head:
                    prev_node = prev_node.parent
                return prev_node.data
            
            for item in self.graph[cur][0]:
                if item not in visited:
                    q.append(item)
                    cur_node.next = Node(item)
                    cur_node = cur_node.next
                    cur_node.parent = prev_node
        print("Path not found")
        return False

    def agent2_main(self, t_pos):
        self.setT(t_pos)
        self.agent0()
        a = self.printA()
        t = self.printT()
        if t == a:
            print("Target is catched by agent_0 at position " + t + "!")
            return True
        else:
            while not t == a:
                print("After one timestep, Tagret move to:")
                self.target_randomwalk(t)
                t = self.printT()
                if t == a:
                    print("Target is catched by agent_0 at position " + t + "!")
                    return True
                a_next_pos = self.DFS()
                self.graph[a][2] = 0
                self.graph[a_next_pos][2] = 1
                a = a_next_pos
                if t == a:
                    print("Target is catched by agent_1 at position " + t + "!")
                    return True
        return False
        
    



# test part
""" Test for agent 0
g = graph()
g.EvnSet(40)
g.printNb()
g.agent0_main(29)
"""


"""Test for agent 1
g = graph()
g.EvnSet(40)
g.printNb()
g.agent1_main(29)
"""

g = graph()
g.EvnSet(40)
g.printNb()
g.agent2_main(29)
